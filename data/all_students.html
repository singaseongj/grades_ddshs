<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>전체 학생 성적 분석</title>
  <link rel="stylesheet" href="../style.css" />
  <style>
    html, body { width: 100%; min-width: 100%; overflow-x: auto; }
    .analysis-container { margin-top: 20px; max-width: none; width: 100%; }
    .analysis-container h1 { margin-bottom: 10px; }
    .analysis-container .description { color: #555; margin-bottom: 25px; }

    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      margin-bottom: 18px;
      background-color: #e8f0fe;
      color: #1a73e8;
      border-radius: 999px;
      font-weight: 600;
      text-decoration: none;
      box-shadow: 0 1px 3px rgba(26, 39, 86, 0.15);
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .back-button:hover {
      background-color: #d2e3fc;
      color: #0c47a1;
    }

    .back-button .icon {
      font-size: 18px;
      line-height: 1;
    }

    .analysis-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }
    .summary-item {
      background: #f0f4ff;
      border-radius: 10px;
      padding: 14px 20px;
      min-width: 160px;
      box-shadow: 0 1px 4px rgba(26, 39, 86, 0.12);
    }
    .summary-item .label {
      font-size: 14px;
      color: #5f6368;
      display: block;
      margin-bottom: 6px;
    }
    .summary-item .value {
      font-size: 20px;
      font-weight: 600;
      color: #1a237e;
    }

    .empty-state {
      text-align: center;
      background: #fff3e0;
      border-radius: 10px;
      border: 1px solid #ffe0b2;
      padding: 40px 20px;
      color: #8a6d3b;
    }
    .empty-state p { margin-bottom: 18px; font-size: 16px; }

    .link-button {
      display: inline-block;
      padding: 10px 20px;
      background-color: #1a73e8;
      color: #fff;
      border-radius: 6px;
      font-weight: 600;
      text-decoration: none;
    }
    .link-button:hover { background-color: #0c47a1; }

    .analysis-content { margin-top: 10px; }
    .grade-note { color: #5f6368; margin-bottom: 12px; }
    .grade-cell { font-weight: 600; color: #0d47a1; }
    .grade-cell span { display: block; font-size: 12px; color: #5f6368; font-weight: 400; }

    .analysis-table-wrapper,
    .grade-cut-wrapper {
      width: 100%;
      overflow-x: auto;
    }

    .analysis-table-wrapper table { min-width: 1200px; }
    .grade-cut-wrapper table { min-width: 720px; }

    .analysis-table {
      width: 100%;
      table-layout: fixed;
    }
    .analysis-table th {
      position: relative;
      text-align: center;
      white-space: normal;
      word-break: keep-all;
      padding-right: 28px;
      vertical-align: bottom;
      line-height: 1.4;
    }
    .analysis-table td {
      word-break: keep-all;
      white-space: normal;
      line-height: 1.45;
    }

    .analysis-table th span {
      display: block;
      font-weight: 600;
    }

    .analysis-table th .align-button {
      position: absolute;
      top: 6px;
      right: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border: none;
      background: none;
      color: #1a73e8;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
    }

    .analysis-table th .align-button:hover {
      background-color: transparent;
      color: #0c47a1;
    }

    .weight-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 18px;
      align-items: flex-end;
    }

    .weight-controls.hidden {
      display: none;
    }

    .weight-group {
      display: flex;
      flex-direction: column;
      min-width: 130px;
    }

    .weight-group label {
      font-size: 13px;
      color: #5f6368;
      margin-bottom: 6px;
    }

    .weight-group input {
      padding: 6px 10px;
      border: 1px solid #c3c8d4;
      border-radius: 6px;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }

    .grade-cut-container {
      margin-top: 32px;
    }

    .grade-cut-container h2 {
      font-size: 18px;
      margin-bottom: 12px;
      color: #1a237e;
    }

    .grade-cut-table {
      width: 100%;
      border-collapse: collapse;
      background: #f8f9ff;
      border-radius: 10px;
      overflow: hidden;
    }

    .grade-cut-table th,
    .grade-cut-table td {
      border: 1px solid #d9def2;
      padding: 10px 14px;
      text-align: center;
      font-size: 14px;
    }

    .grade-cut-table th {
      background: #e8ecff;
      color: #1a237e;
      font-weight: 600;
    }

    .grade-cut-table td:first-child {
      font-weight: 600;
      color: #1a237e;
      background: #eef1ff;
    }

    @media (max-width: 768px) {
      .summary-item { flex: 1 1 100%; }
      table { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="container analysis-container">
    <a href="../index.html" class="back-button" aria-label="메인 화면으로 돌아가기">
      <span class="icon" aria-hidden="true">←</span>
      <span>메인으로</span>
    </a>
    <h1>전체 학생 성적 분석</h1>
    <p class="description">업로드한 엑셀 데이터를 기반으로 학생별 가중치 합계, 가중치 평균, 과목별 등급컷, 전체 등수를 확인할 수 있습니다.</p>

    <div id="emptyState" class="empty-state" hidden>
      <p>아직 업로드된 학생 성적 데이터가 없습니다. 메인 화면에서 엑셀 파일을 업로드한 뒤 다시 확인해주세요.</p>
      <a class="link-button" href="../index.html">메인 화면으로 이동</a>
    </div>

    <div id="analysisContent" class="analysis-content" hidden>
      <div class="analysis-summary" id="analysisSummary"></div>
      <div id="weightControls" class="weight-controls hidden"></div>
      <p class="grade-note">※ 등급은 1~5등급 비율 (10% / 24% / 32% / 24% / 10%)을 기반으로 과목별 성적 순위를 계산하여 산출됩니다.</p>
      <div class="analysis-table-wrapper">
        <table class="analysis-table">
          <thead id="analysisHead"></thead>
          <tbody id="analysisBody"></tbody>
        </table>
      </div>
      <div id="gradeCutContainer" class="grade-cut-container" hidden>
        <h2>과목별 등급컷</h2>
        <div class="grade-cut-wrapper">
          <table class="grade-cut-table">
            <thead id="gradeCutHead"></thead>
            <tbody id="gradeCutBody"></tbody>
          </table>
        </div>
      </div>
      <div id="subjectStatsContainer" class="grade-cut-container" hidden>
        <h2>과목별 평균/표준편차</h2>
        <div class="grade-cut-wrapper">
          <table class="grade-cut-table">
            <thead id="subjectStatsHead"></thead>
            <tbody id="subjectStatsBody"></tbody>
          </table>
        </div>
      </div>
      <div id="classAverageContainer" class="grade-cut-container" hidden>
        <h2>반 평균</h2>
        <div class="grade-cut-wrapper">
          <table class="grade-cut-table">
            <thead id="classAverageHead"></thead>
            <tbody id="classAverageBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    const SUBJECTS = [
      '공통수학1','공통수학2','통합과학1','통합과학2','융합탐구','공통국어1','공통영어1','통합사회1',
      '대수','미적분','역학과 에너지','화학','생명과학','지구과학','정보과학','공통국어2','공통영어2','통합사회2'
    ];
    const DEFAULT_SUBJECT_WEIGHTS = [
      3, 3, 4, 4, 3, 3, 3, 3,
      3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    ];
    const SUBJECT_DISPLAY_NAMES = {
      '공통국어1': '공통국어 (1학기)',
      '공통국어2': '공통국어 (2학기)',
      '공통영어1': '공통영어 (1학기)',
      '공통영어2': '공통영어 (2학기)',
      '통합사회1': '통합사회 (1학기)',
      '통합사회2': '통합사회 (2학기)',
      '공통수학1': '공통수학1 (1학기)',
      '공통수학2': '공통수학2 (1학기)',
      '통합과학1': '통합과학1 (1학기)',
      '통합과학2': '통합과학2 (1학기)',
      '융합탐구': '융합탐구 (1학기)',
      '대수': '대수 (2학기)',
      '미적분': '미적분 (2학기)',
      '역학과 에너지': '역학과 에너지 (2학기)',
      '화학': '화학 (2학기)',
      '생명과학': '생명과학 (2학기)',
      '지구과학': '지구과학 (2학기)',
      '정보과학': '정보과학 (2학기)'
    };
    const SUBJECTS_WITHOUT_GRADES = new Set(['융합탐구']);
    const GRADE_CONFIG = [10, 24, 32, 24, 10];
    const GRADE_LEVELS = [1, 2, 3, 4, 5];
    const STORAGE_KEY = 'grades:studentDataset';
    const EXAM_STEPS = [
      { key: 'semester1', label: '1학기' },
      { key: 'semester2', label: '2학기' }
    ];
    const SUBJECT_COUNT = SUBJECTS.length;
    let currentStudents = [];
    let currentSortKey = 'overallRank';
    let subjectWeights = [...DEFAULT_SUBJECT_WEIGHTS];

    function normalizeWeightValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      const rounded = Math.round(numeric);
      return Math.max(0, rounded);
    }

    function createEmptyTermSubjectAvailability() {
      const result = {};
      EXAM_STEPS.forEach(({ key }) => {
        result[key] = Array(SUBJECT_COUNT).fill(false);
      });
      return result;
    }

    function computeTermSubjectAvailability(dataset) {
      const availability = createEmptyTermSubjectAvailability();
      if (!dataset || typeof dataset !== 'object') return availability;

      Object.values(dataset).forEach(info => {
        EXAM_STEPS.forEach(({ key }) => {
          const termScores = info?.[key];
          if (!Array.isArray(termScores)) return;
          termScores.forEach((value, index) => {
            const numeric = toFiniteNumber(value);
            if (Number.isFinite(numeric)) {
              availability[key][index] = true;
            }
          });
        });
      });

      return availability;
    }

    function deriveActiveSubjectIndices(availability) {
      return SUBJECTS.map((_, index) => index).filter(index => {
        return EXAM_STEPS.some(({ key }) => availability?.[key]?.[index]);
      });
    }

    let termSubjectAvailability = createEmptyTermSubjectAvailability();
    let activeSubjectIndices = [];
    let activeSubjectIndexSet = new Set();

    function updateSubjectAvailabilityFromDataset(dataset) {
      termSubjectAvailability = computeTermSubjectAvailability(dataset);
      activeSubjectIndices = deriveActiveSubjectIndices(termSubjectAvailability);
      activeSubjectIndexSet = new Set(activeSubjectIndices);
    }

    function isSubjectActive(index) {
      return activeSubjectIndexSet.has(index);
    }

    function isSubjectAvailableForTerm(termKey, index) {
      return Boolean(termSubjectAvailability?.[termKey]?.[index]);
    }

    function getActiveSubjectIndices() {
      return activeSubjectIndices;
    }

    const SORT_HANDLERS = {
      overallRank: (a, b) => {
        const result = compareNumericAsc(a.overallRank, b.overallRank);
        if (result !== 0) return result;
        return a.name.localeCompare(b.name, 'ko');
      },
      name: (a, b) => {
        const result = compareStringAsc(a.name, b.name);
        if (result !== 0) return result;
        return compareNumericAsc(a.studentId, b.studentId);
      },
      studentId: (a, b) => {
        const result = compareNumericAsc(a.studentId, b.studentId);
        if (result !== 0) return result;
        return a.name.localeCompare(b.name, 'ko');
      },
      weightedSum: (a, b) => {
        const result = compareNumericDesc(a.weightedSum, b.weightedSum);
        if (result !== 0) return result;
        return a.name.localeCompare(b.name, 'ko');
      },
      weightedAverage: (a, b) => {
        const result = compareNumericDesc(a.weightedAverage, b.weightedAverage);
        if (result !== 0) return result;
        return a.name.localeCompare(b.name, 'ko');
      },
      averageGrade: (a, b) => {
        const result = compareNumericAsc(a.averageGradeValue, b.averageGradeValue);
        if (result !== 0) return result;
        return a.name.localeCompare(b.name, 'ko');
      }
    };

    SUBJECTS.forEach((_, index) => {
      SORT_HANDLERS[`subject-${index}`] = (a, b) => {
        const scoreCompare = compareNumericDesc(a.subjectAverages[index], b.subjectAverages[index]);
        if (scoreCompare !== 0) return scoreCompare;
        const gradeCompare = compareNumericAsc(a.subjectGrades[index], b.subjectGrades[index]);
        if (gradeCompare !== 0) return gradeCompare;
        return a.name.localeCompare(b.name, 'ko');
      };
    });

    function loadStudentDataset() {
      if (typeof localStorage === 'undefined') return null;
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : null;
      } catch (err) {
        console.error('저장된 학생 데이터를 불러오는 중 문제가 발생했습니다.', err);
        return null;
      }
    }

    function formatNumber(value, digits = 1) {
      if (!Number.isFinite(value)) return '-';
      return value.toLocaleString('ko-KR', {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits
      });
    }

    function formatScoreDisplay(value) {
      if (!Number.isFinite(value)) return '-';
      const hasDecimal = Math.abs(value - Math.round(value)) > 1e-6;
      return formatNumber(value, hasDecimal ? 1 : 0);
    }

    function compareNumericAsc(rawA, rawB) {
      const a = Number.isFinite(rawA) ? rawA : Infinity;
      const b = Number.isFinite(rawB) ? rawB : Infinity;
      if (a < b) return -1;
      if (a > b) return 1;
      return 0;
    }

    function compareNumericDesc(rawA, rawB) {
      const a = Number.isFinite(rawA) ? rawA : -Infinity;
      const b = Number.isFinite(rawB) ? rawB : -Infinity;
      if (a > b) return -1;
      if (a < b) return 1;
      return 0;
    }

    function compareStringAsc(rawA, rawB) {
      const a = rawA ?? '';
      const b = rawB ?? '';
      return String(a).localeCompare(String(b), 'ko');
    }

    function toFiniteNumber(value) {
      if (value === null || value === undefined) return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === 'string' && value.trim() === '') {
        return null;
      }
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : null;
    }

    function sanitizeTermScores(term) {
      if (!Array.isArray(term)) {
        return Array(SUBJECTS.length).fill(null);
      }
      return SUBJECTS.map((_, index) => {
        if (index >= term.length) return null;
        const numeric = toFiniteNumber(term[index]);
        return Number.isFinite(numeric) ? numeric : null;
      });
    }

    function calculateSubjectAverage(student, index) {
      if (!isSubjectActive(index)) return null;
      const terms = [student.semester1, student.semester2];
      const scores = [];
      terms.forEach(term => {
        if (!Array.isArray(term) || term.length <= index) return;
        const sanitizedScore = toFiniteNumber(term[index]);
        if (Number.isFinite(sanitizedScore)) {
          scores.push(sanitizedScore);
        }
      });
      if (scores.length === 0) return null;
      const total = scores.reduce((sum, value) => sum + value, 0);
      return total / scores.length;
    }

    function buildStudentSummaries(dataset) {
      return Object.entries(dataset).map(([name, info]) => {
        const studentId = toFiniteNumber(info.number);
        let studentIdText = '';
        if (info?.number !== undefined && info?.number !== null) {
          studentIdText = String(info.number).trim();
        }
        if (!studentIdText && Number.isFinite(studentId)) {
          studentIdText = String(studentId);
        }
        const normalizedSemesters = {
          semester1: sanitizeTermScores(info.semester1),
          semester2: sanitizeTermScores(info.semester2)
        };
        const subjectAverages = SUBJECTS.map((_, idx) => calculateSubjectAverage(normalizedSemesters, idx));
        const validScores = subjectAverages.filter(value => Number.isFinite(value));
        const totalScore = validScores.reduce((sum, value) => sum + value, 0);
        const averageScore = validScores.length > 0 ? totalScore / validScores.length : null;
        return {
          key: `${name}__${info.number ?? ''}`,
          name,
          studentId,
          studentIdText,
          subjectAverages,
          subjectGrades: Array(SUBJECTS.length).fill(null),
          subjectRanks: Array(SUBJECTS.length).fill(null),
          sum: totalScore,
          average: averageScore,
          weightedSum: 0,
          weightedAverage: null,
          averageGradeValue: null,
          averageGradeText: '-',
          overallRank: 0
        };
      });
    }

    function computeGradeSlices(total) {
      if (total <= 0) return [];
      const slices = [];
      let cumulativeEstimate = 0;
      let previousEnd = 0;

      GRADE_CONFIG.forEach((percent, index) => {
        cumulativeEstimate += total * (percent / 100);
        let endRank = Math.round(cumulativeEstimate);
        if (index === GRADE_CONFIG.length - 1) {
          endRank = total;
        } else {
          endRank = Math.min(endRank, total);
        }
        if (endRank < previousEnd) {
          endRank = previousEnd;
        }
        const startRank = previousEnd + 1;
        const adjustedEnd = Math.max(endRank, startRank - 1);
        slices.push({ grade: index + 1, startRank, endRank: adjustedEnd });
        previousEnd = adjustedEnd;
      });

      const lastSlice = slices[slices.length - 1];
      if (lastSlice && lastSlice.endRank < total) {
        lastSlice.endRank = total;
      }
      return slices;
    }

    function assignSubjectGrades(students) {
      if (!students.length) return;
      SUBJECTS.forEach((subjectName, subjectIndex) => {
        if (!isSubjectActive(subjectIndex)) return;
        const skipGrade = SUBJECTS_WITHOUT_GRADES.has(subjectName);
        const candidates = students.filter(student => Number.isFinite(student.subjectAverages[subjectIndex]));
        if (!candidates.length) return;
        const ordered = [...candidates].sort((a, b) => b.subjectAverages[subjectIndex] - a.subjectAverages[subjectIndex]);
        const gradeSlices = skipGrade ? [] : computeGradeSlices(ordered.length);
        let previousScore = null;
        let previousRank = 0;
        let previousGrade = null;

        ordered.forEach((student, index) => {
          const score = student.subjectAverages[subjectIndex];
          const isTie = previousScore !== null && Math.abs(previousScore - score) < 1e-6;
          const rank = isTie ? previousRank : index + 1;
          const slice = gradeSlices.find(range => rank >= range.startRank && rank <= range.endRank) || gradeSlices[gradeSlices.length - 1];
          const gradeValue = slice ? slice.grade : null;
          const finalGrade = isTie && previousGrade !== null ? previousGrade : gradeValue;
          student.subjectGrades[subjectIndex] = skipGrade ? null : finalGrade;
          student.subjectRanks[subjectIndex] = rank;
          if (!isTie) {
            previousScore = score;
            previousRank = rank;
            previousGrade = finalGrade;
          }
        });
      });
    }

    function assignOverallRanks(students) {
      if (!students.length) return;
      const ordered = [...students].sort((a, b) => {
        const scoreA = Number.isFinite(a.weightedSum) ? a.weightedSum : -Infinity;
        const scoreB = Number.isFinite(b.weightedSum) ? b.weightedSum : -Infinity;
        return scoreB - scoreA;
      });
      let previousScore = null;
      let previousRank = 0;

      ordered.forEach((student, index) => {
        const score = Number.isFinite(student.weightedSum) ? student.weightedSum : null;
        const isTie = previousScore !== null && Math.abs(previousScore - score) < 1e-6;
        const rank = isTie ? previousRank : index + 1;
        student.overallRank = rank;
        if (!isTie) {
          previousScore = score;
          previousRank = rank;
        }
      });
    }

    function assignAverageGrades(students) {
      students.forEach(student => {
        const gradeValues = student.subjectGrades.filter((value, index) => {
          return isSubjectActive(index) && Number.isFinite(value);
        });
        if (!gradeValues.length) {
          student.averageGradeValue = null;
          student.averageGradeText = '-';
          return;
        }
        const total = gradeValues.reduce((sum, value) => sum + value, 0);
        const averageGrade = total / gradeValues.length;
        student.averageGradeValue = averageGrade;
        student.averageGradeText = `${formatNumber(averageGrade, 1)}등급`;
      });
    }

    function applyWeights(students) {
      if (!Array.isArray(students) || !students.length) return;
      const sanitizedWeights = subjectWeights.map((value, index) => {
        if (!isSubjectActive(index)) return 0;
        const normalized = normalizeWeightValue(value);
        return normalized > 0 ? normalized : 0;
      });

      students.forEach(student => {
        let weightedSum = 0;
        let appliedWeight = 0;
        student.subjectAverages.forEach((score, index) => {
          const weight = sanitizedWeights[index] ?? 0;
          if (!Number.isFinite(score) || weight <= 0) return;
          weightedSum += score * weight;
          appliedWeight += weight;
        });

        student.weightedSum = appliedWeight > 0 ? weightedSum : null;
        student.weightedAverage = appliedWeight > 0 ? weightedSum / appliedWeight : null;
      });
    }

    function calculateGradeCutlines(students) {
      if (!Array.isArray(students) || !students.length) {
        return SUBJECTS.map(() => ({}));
      }

      return SUBJECTS.map((subjectName, subjectIndex) => {
        if (!isSubjectActive(subjectIndex)) {
          return {};
        }
        if (SUBJECTS_WITHOUT_GRADES.has(subjectName)) {
          return {};
        }
        const candidates = students.filter(student => Number.isFinite(student.subjectAverages[subjectIndex]));
        if (!candidates.length) return {};
        const ordered = [...candidates].sort((a, b) => b.subjectAverages[subjectIndex] - a.subjectAverages[subjectIndex]);
        const gradeSlices = computeGradeSlices(ordered.length);
        const cutlines = {};

        gradeSlices.forEach(slice => {
          const sliceStudents = ordered.slice(slice.startRank - 1, slice.endRank);
          if (!sliceStudents.length) return;
          const lowestScore = sliceStudents[sliceStudents.length - 1].subjectAverages[subjectIndex];
          if (Number.isFinite(lowestScore)) {
            cutlines[slice.grade] = lowestScore;
          }
        });

        return cutlines;
      });
    }

    function renderGradeCutTable(students) {
      const container = document.getElementById('gradeCutContainer');
      const head = document.getElementById('gradeCutHead');
      const body = document.getElementById('gradeCutBody');
      if (!container || !head || !body) return;

      head.innerHTML = '';
      body.innerHTML = '';

      if (!students.length) {
        container.hidden = true;
        return;
      }

      const activeIndices = getActiveSubjectIndices();
      if (!activeIndices.length) {
        container.hidden = true;
        return;
      }

      const gradeCutlines = calculateGradeCutlines(students);
      const headRow = document.createElement('tr');
      const titleTh = document.createElement('th');
      titleTh.textContent = '등급컷';
      headRow.appendChild(titleTh);
      activeIndices.forEach(subjectIndex => {
        const subject = SUBJECTS[subjectIndex];
        const th = document.createElement('th');
        th.textContent = SUBJECT_DISPLAY_NAMES[subject] || subject;
        headRow.appendChild(th);
      });
      head.appendChild(headRow);

      GRADE_LEVELS.forEach(level => {
        const tr = document.createElement('tr');
        const gradeCell = document.createElement('td');
        gradeCell.textContent = `${level}등급`;
        tr.appendChild(gradeCell);

        activeIndices.forEach(subjectIndex => {
          const td = document.createElement('td');
          const score = gradeCutlines[subjectIndex]?.[level];
          td.textContent = Number.isFinite(score) ? formatNumber(score, 2) : '-';
          tr.appendChild(td);
        });

        body.appendChild(tr);
      });

      container.hidden = false;
    }

    function calculateSubjectStats(students) {
      if (!Array.isArray(students) || !students.length) {
        return SUBJECTS.map(() => ({ mean: null, stdDev: null }));
      }

      return SUBJECTS.map((_, subjectIndex) => {
        if (!isSubjectActive(subjectIndex)) {
          return { mean: null, stdDev: null };
        }
        const scores = students
          .map(student => student.subjectAverages[subjectIndex])
          .filter(score => Number.isFinite(score));
        if (!scores.length) {
          return { mean: null, stdDev: null };
        }
        const mean = scores.reduce((sum, value) => sum + value, 0) / scores.length;
        const variance = scores.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / scores.length;
        const stdDev = Math.sqrt(variance);
        return { mean, stdDev };
      });
    }

    function renderSubjectStatsTable(students) {
      const container = document.getElementById('subjectStatsContainer');
      const head = document.getElementById('subjectStatsHead');
      const body = document.getElementById('subjectStatsBody');
      if (!container || !head || !body) return;

      head.innerHTML = '';
      body.innerHTML = '';

      if (!students.length) {
        container.hidden = true;
        return;
      }

      const activeIndices = getActiveSubjectIndices();
      if (!activeIndices.length) {
        container.hidden = true;
        return;
      }

      const stats = calculateSubjectStats(students);
      const hasData = activeIndices.some(index => Number.isFinite(stats[index]?.mean));
      if (!hasData) {
        container.hidden = true;
        return;
      }

      const headRow = document.createElement('tr');
      const titleTh = document.createElement('th');
      titleTh.textContent = '구분';
      headRow.appendChild(titleTh);
      activeIndices.forEach(subjectIndex => {
        const subject = SUBJECTS[subjectIndex];
        const th = document.createElement('th');
        th.textContent = SUBJECT_DISPLAY_NAMES[subject] || subject;
        headRow.appendChild(th);
      });
      head.appendChild(headRow);

      const meanRow = document.createElement('tr');
      const meanLabel = document.createElement('td');
      meanLabel.textContent = '평균';
      meanRow.appendChild(meanLabel);

      activeIndices.forEach(subjectIndex => {
        const stat = stats[subjectIndex] || {};
        const td = document.createElement('td');
        td.textContent = Number.isFinite(stat.mean) ? formatNumber(stat.mean, 2) : '-';
        meanRow.appendChild(td);
      });
      body.appendChild(meanRow);

      const stdRow = document.createElement('tr');
      const stdLabel = document.createElement('td');
      stdLabel.textContent = '표준편차';
      stdRow.appendChild(stdLabel);

      activeIndices.forEach(subjectIndex => {
        const stat = stats[subjectIndex] || {};
        const td = document.createElement('td');
        td.textContent = Number.isFinite(stat.stdDev) ? formatNumber(stat.stdDev, 2) : '-';
        stdRow.appendChild(td);
      });
      body.appendChild(stdRow);

      container.hidden = false;
    }

    function extractClassNumber(student) {
      const rawId = typeof student.studentIdText === 'string' ? student.studentIdText : '';
      const digits = rawId.replace(/\D/g, '');
      if (digits.length < 2) return null;
      const classDigit = digits.charAt(1);
      return classDigit ? Number(classDigit) : null;
    }

    function calculateClassSubjectAverages(students) {
      const classScores = new Map();

      students.forEach(student => {
        const classNumber = extractClassNumber(student);
        if (!Number.isFinite(classNumber)) return;
        if (!classScores.has(classNumber)) {
          classScores.set(classNumber, SUBJECTS.map(() => []));
        }
        const subjectLists = classScores.get(classNumber);
        student.subjectAverages.forEach((score, index) => {
          if (!isSubjectActive(index)) return;
          if (!Number.isFinite(score)) return;
          subjectLists[index].push(score);
        });
      });

      return Array.from(classScores.entries())
        .map(([classNumber, subjectScores]) => {
          const subjectAverages = subjectScores.map(scores => {
            if (!scores.length) return null;
            const total = scores.reduce((sum, value) => sum + value, 0);
            return total / scores.length;
          });
          return {
            classNumber,
            subjectAverages
          };
        })
        .filter(entry => entry.subjectAverages.some(score => Number.isFinite(score)))
        .sort((a, b) => a.classNumber - b.classNumber);
    }

    function renderClassAverageTable(students) {
      const container = document.getElementById('classAverageContainer');
      const head = document.getElementById('classAverageHead');
      const body = document.getElementById('classAverageBody');
      if (!container || !head || !body) return;

      head.innerHTML = '';
      body.innerHTML = '';

      if (!students.length) {
        container.hidden = true;
        return;
      }

      const averages = calculateClassSubjectAverages(students);
      if (!averages.length) {
        container.hidden = true;
        return;
      }

      const activeIndices = getActiveSubjectIndices();
      if (!activeIndices.length) {
        container.hidden = true;
        return;
      }

      const headRow = document.createElement('tr');
      const classTh = document.createElement('th');
      classTh.textContent = '반';
      headRow.appendChild(classTh);
      activeIndices.forEach(subjectIndex => {
        const subject = SUBJECTS[subjectIndex];
        const th = document.createElement('th');
        th.textContent = SUBJECT_DISPLAY_NAMES[subject] || subject;
        headRow.appendChild(th);
      });
      head.appendChild(headRow);

      averages.forEach(entry => {
        const tr = document.createElement('tr');
        const classTd = document.createElement('td');
        classTd.textContent = `${entry.classNumber}반`;
        tr.appendChild(classTd);
        activeIndices.forEach(subjectIndex => {
          const score = entry.subjectAverages[subjectIndex];
          const td = document.createElement('td');
          td.textContent = Number.isFinite(score) ? formatNumber(score, 2) : '-';
          tr.appendChild(td);
        });
        body.appendChild(tr);
      });

      container.hidden = false;
    }

    function onWeightChanged() {
      if (!currentStudents.length) return;
      applyWeights(currentStudents);
      assignOverallRanks(currentStudents);
      renderSummary(currentStudents);
      renderGradeCutTable(currentStudents);
      renderSubjectStatsTable(currentStudents);
      renderClassAverageTable(currentStudents);
      const targetSortKey = SORT_HANDLERS[currentSortKey] ? currentSortKey : 'overallRank';
      sortStudents(targetSortKey);
    }

    function createWeightControls() {
      const container = document.getElementById('weightControls');
      if (!container) return;

      container.innerHTML = '';
      const activeIndices = getActiveSubjectIndices();
      if (!activeIndices.length) {
        container.classList.add('hidden');
        return;
      }

      activeIndices.forEach(index => {
        const subject = SUBJECTS[index];
        const group = document.createElement('div');
        group.className = 'weight-group';

        const label = document.createElement('label');
        const inputId = `weight-${index}`;
        label.setAttribute('for', inputId);
        const displayName = SUBJECT_DISPLAY_NAMES[subject] || subject;
        label.textContent = `${displayName} 가중치`;

        const input = document.createElement('input');
        input.type = 'number';
        input.id = inputId;
        input.min = '0';
        input.step = '1';
        const defaultValue = normalizeWeightValue(subjectWeights[index]);
        subjectWeights[index] = defaultValue;
        input.value = defaultValue;

        const syncWeightValue = () => {
          const normalized = normalizeWeightValue(input.value);
          if (String(normalized) !== input.value) {
            input.value = normalized;
          }
          const hasChanged = subjectWeights[index] !== normalized;
          subjectWeights[index] = normalized;
          return hasChanged;
        };

        input.addEventListener('input', () => {
          if (syncWeightValue()) {
            onWeightChanged();
          }
        });

        input.addEventListener('blur', () => {
          if (syncWeightValue()) {
            onWeightChanged();
          }
        });

        group.appendChild(label);
        group.appendChild(input);
        container.appendChild(group);
      });

      container.classList.remove('hidden');
    }

    function createHeaderCell(label, sortKey) {
      const th = document.createElement('th');
      const labelSpan = document.createElement('span');
      labelSpan.textContent = label;
      th.appendChild(labelSpan);
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'align-button';
      button.innerHTML = '<span aria-hidden="true">☰</span>';
      button.title = `${label} 정렬`;
      button.setAttribute('aria-label', `${label} 정렬`);
      button.addEventListener('click', () => sortStudents(sortKey));
      th.appendChild(button);
      return th;
    }

    function sortStudents(sortKey) {
      if (!Array.isArray(currentStudents) || currentStudents.length === 0) return;
      const key = SORT_HANDLERS[sortKey] ? sortKey : 'overallRank';
      const comparator = SORT_HANDLERS[key];
      if (typeof comparator !== 'function') return;
      currentSortKey = key;
      currentStudents.sort(comparator);
      renderTableRows(currentStudents);
    }

    function buildTableHeader() {
      const head = document.getElementById('analysisHead');
      head.innerHTML = '';
      const row = document.createElement('tr');
      const baseHeaders = [
        { label: '전체 등수', sortKey: 'overallRank' },
        { label: '이름', sortKey: 'name' },
        { label: '학번', sortKey: 'studentId' },
        { label: '가중치 합계', sortKey: 'weightedSum' },
        { label: '가중치 평균', sortKey: 'weightedAverage' },
        { label: '등급 평균', sortKey: 'averageGrade' }
      ];
      baseHeaders.forEach(({ label, sortKey }) => {
        row.appendChild(createHeaderCell(label, sortKey));
      });
      const activeIndices = getActiveSubjectIndices();
      activeIndices.forEach(index => {
        const subject = SUBJECTS[index];
        const displayName = SUBJECT_DISPLAY_NAMES[subject] || subject;
        const hasGrade = !SUBJECTS_WITHOUT_GRADES.has(subject);
        const label = hasGrade ? `${displayName} (등수) / 등급` : `${displayName} (등수)`;
        const th = createHeaderCell(label, `subject-${index}`);
        row.appendChild(th);
      });
      head.appendChild(row);
    }

    function renderTableRows(students) {
      const body = document.getElementById('analysisBody');
      body.innerHTML = '';
      const activeIndices = getActiveSubjectIndices();
      students.forEach(student => {
        const row = document.createElement('tr');

        const rankCell = document.createElement('td');
        rankCell.textContent = Number.isFinite(student.overallRank)
          ? String(student.overallRank)
          : '-';
        row.appendChild(rankCell);

        const nameCell = document.createElement('td');
        nameCell.textContent = student.name;
        row.appendChild(nameCell);

        const idCell = document.createElement('td');
        idCell.textContent = Number.isFinite(student.studentId)
          ? String(student.studentId)
          : '-';
        row.appendChild(idCell);

        const sumCell = document.createElement('td');
        sumCell.textContent = formatNumber(student.weightedSum, 2);
        row.appendChild(sumCell);

        const avgCell = document.createElement('td');
        avgCell.textContent = formatNumber(student.weightedAverage, 2);
        row.appendChild(avgCell);

        const avgGradeCell = document.createElement('td');
        avgGradeCell.classList.add('grade-cell');
        avgGradeCell.textContent = student.averageGradeText ?? '-';
        row.appendChild(avgGradeCell);

        activeIndices.forEach(index => {
          const grade = student.subjectGrades[index];
          const td = document.createElement('td');
          td.classList.add('grade-cell');
          const averageScore = student.subjectAverages[index];
          const scoreText = formatScoreDisplay(averageScore);
          const rankValue = student.subjectRanks?.[index];
          const rankText = Number.isFinite(rankValue) ? rankValue : '-';
          const subjectName = SUBJECTS[index];
          const hasGrade = !SUBJECTS_WITHOUT_GRADES.has(subjectName);
          if (hasGrade) {
            const gradeText = Number.isFinite(grade) ? grade : '-';
            td.textContent = `${scoreText} (${rankText}) / ${gradeText}`;
          } else {
            td.textContent = `${scoreText} (${rankText})`;
          }
          if (Number.isFinite(averageScore)) {
            const subjectLabel = SUBJECT_DISPLAY_NAMES[SUBJECTS[index]] || SUBJECTS[index];
            td.title = `${subjectLabel} 평균: ${formatNumber(averageScore, 1)}점`;
          }
          row.appendChild(td);
        });

        body.appendChild(row);
      });
    }

    function renderSummary(students) {
      const summary = document.getElementById('analysisSummary');
      summary.innerHTML = '';
      if (!students.length) return;
      const items = [
        { label: '총 학생 수', value: `${students.length.toLocaleString('ko-KR')}명` }
      ];

      items.forEach(({ label, value }) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'summary-item';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.className = 'value';
        valueEl.textContent = value;
        wrapper.appendChild(labelEl);
        wrapper.appendChild(valueEl);
        summary.appendChild(wrapper);
      });
    }

    function initialize() {
      const dataset = loadStudentDataset();
      const emptyState = document.getElementById('emptyState');
      const analysisContent = document.getElementById('analysisContent');

      if (!dataset || Object.keys(dataset).length === 0) {
        emptyState.hidden = false;
        analysisContent.hidden = true;
        return;
      }

      updateSubjectAvailabilityFromDataset(dataset);

      const students = buildStudentSummaries(dataset);
      if (!students.length) {
        emptyState.hidden = false;
        analysisContent.hidden = true;
        return;
      }

      currentStudents = students;
      subjectWeights = SUBJECTS.map((_, index) => (
        isSubjectActive(index) ? (DEFAULT_SUBJECT_WEIGHTS[index] ?? 0) : 0
      ));
      assignSubjectGrades(currentStudents);
      assignAverageGrades(currentStudents);
      applyWeights(currentStudents);
      assignOverallRanks(currentStudents);
      buildTableHeader();
      renderSummary(currentStudents);
      renderGradeCutTable(currentStudents);
      renderSubjectStatsTable(currentStudents);
      renderClassAverageTable(currentStudents);
      createWeightControls();
      sortStudents('overallRank');

      emptyState.hidden = true;
      analysisContent.hidden = false;
    }

    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
