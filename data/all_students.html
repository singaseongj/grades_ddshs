<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>전체 학생 성적 분석</title>
  <link rel="stylesheet" href="../style.css" />
  <style>
    body { background: #eef2f7; }
    .summary-container {
      max-width: 1280px;
      margin: 30px auto;
      background: #ffffff;
      padding: 32px;
      border-radius: 18px;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.12);
    }
    .summary-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }
    .summary-header h1 {
      margin: 0;
      font-size: 2.1rem;
      color: #0f172a;
      text-align: center;
    }
    .summary-links {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .summary-links a {
      padding: 8px 16px;
      border-radius: 999px;
      background: #e8f0fe;
      color: #0b57d0;
      font-weight: 600;
      text-decoration: none;
      transition: background-color 0.2s ease, color 0.2s ease, transform 0.15s ease;
    }
    @media (hover: hover) and (pointer: fine) {
      .summary-links a:hover {
        background: #d2e3fc;
        color: #0840a3;
        transform: translateY(-1px);
      }
    }
    .summary-links a:focus { outline: 2px solid #0b57d0; outline-offset: 2px; }
    .summary-description {
      margin: 0 auto 18px;
      max-width: 760px;
      text-align: center;
      color: #475569;
      line-height: 1.6;
      font-size: 1rem;
    }
    .analysis-notice {
      margin-bottom: 20px;
      padding: 14px 18px;
      border-radius: 10px;
      background: #f1f5f9;
      color: #1e293b;
      font-weight: 600;
    }
    .analysis-notice.warning {
      background: #fdecea;
      color: #b71c1c;
      border: 1px solid #f5c6cb;
    }
    .table-wrapper { overflow-x: auto; }
    table#analysisTable { width: 100%; border-collapse: collapse; margin-top: 0; }
    #analysisTable th, #analysisTable td {
      padding: 12px 10px;
      border: 1px solid #e2e8f0;
      text-align: center;
      font-size: 0.95rem;
    }
    #analysisTable thead th {
      background: #0b57d0;
      color: #ffffff;
      font-size: 1rem;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    #analysisTable tbody tr:nth-child(even) { background: #f8fbff; }
    #analysisTable tbody tr:hover { background: #eef6ff; }
    .subject-grade {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      min-width: 120px;
    }
    .subject-grade .score { font-weight: 600; color: #1f2937; }
    .grade-tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 52px;
      padding: 2px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 700;
      color: #ffffff;
      letter-spacing: 0.01em;
    }
    .grade-tag.is-1 { background: #c62828; }
    .grade-tag.is-2 { background: #ef6c00; }
    .grade-tag.is-3 { background: #2e7d32; }
    .grade-tag.is-4 { background: #1565c0; }
    .grade-tag.is-5 { background: #6a1b9a; }
    .rank-cell { font-weight: 700; color: #0f172a; }
    .summary-note {
      margin-top: 18px;
      color: #64748b;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    @media (max-width: 768px) {
      .summary-container { margin: 16px; padding: 24px 18px; }
      .subject-grade { min-width: 100px; }
    }
  </style>
</head>
<body>
  <div class="summary-container">
    <header class="summary-header">
      <h1>전체 학생 성적 분석</h1>
      <div class="summary-links">
        <a href="../index.html">메인으로</a>
        <a href="grade_cal.html">등급계산기</a>
      </div>
    </header>
    <p class="summary-description">
      업로드한 엑셀 데이터를 기반으로 학생들의 과목별 평균 점수와 등급, 전체 등수를 계산해 보여줍니다.
      데이터가 없다면 먼저 메인 페이지에서 엑셀 파일을 업로드하세요.
    </p>
    <div id="analysisNotice" class="analysis-notice"></div>
    <div id="analysisTableWrapper" class="table-wrapper" style="display:none;">
      <table id="analysisTable">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
    <p class="summary-note">
      ※ 과목별 등급은 전체 학생의 해당 과목 평균 점수 순위를 기준으로 1~5등급(10% / 24% / 32% / 24% / 10%)을 부여하며, 동점자는 같은 등급을 받습니다.
    </p>
  </div>
  <script>
    const STORAGE_KEY = 'gradesApp.studentDataset';
    const FALLBACK_SUBJECTS = ['공통국어','공통수학','공통영어','한국사','통합사회','통합과학'];
    const GRADE_CONFIG = [
      { label: '1등급', percent: 10 },
      { label: '2등급', percent: 24 },
      { label: '3등급', percent: 32 },
      { label: '4등급', percent: 24 },
      { label: '5등급', percent: 10 }
    ];

    const noticeEl = document.getElementById('analysisNotice');
    const tableWrapper = document.getElementById('analysisTableWrapper');
    const tableHead = document.querySelector('#analysisTable thead');
    const tableBody = document.querySelector('#analysisTable tbody');

    init();

    function init() {
      const data = loadData();
      if (!data) {
        showWarning('저장된 학생 데이터가 없습니다. 메인 페이지에서 엑셀 파일을 업로드한 뒤 다시 확인해주세요.');
        return;
      }

      const { subjects, students } = data;
      const entries = Object.entries(students || {});
      if (!entries.length) {
        showWarning('분석할 학생 데이터가 비어 있습니다. 엑셀 파일의 내용을 확인해주세요.');
        return;
      }

      renderTable(subjects, entries);
    }

    function loadData() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return null;
      }
      try {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object' || !parsed.students) return null;
        const subjects = Array.isArray(parsed.subjects) && parsed.subjects.length ? parsed.subjects : FALLBACK_SUBJECTS;
        return { subjects, students: parsed.students };
      } catch (err) {
        console.error('데이터를 불러오는 중 오류가 발생했습니다.', err);
        return null;
      }
    }

    function showWarning(message) {
      noticeEl.textContent = message;
      noticeEl.classList.add('warning');
      tableWrapper.style.display = 'none';
    }

    function renderTable(subjects, entries) {
      const summaries = entries.map(([name, info]) => buildStudentSummary(name, info, subjects));
      const overallRanks = computeOverallRanks(summaries);
      const subjectGrades = computeSubjectGrades(subjects, summaries);
      const collator = new Intl.Collator('ko');

      const sorted = summaries.slice().sort((a, b) => {
        const rankA = rankValue(overallRanks[a.name]);
        const rankB = rankValue(overallRanks[b.name]);
        if (rankA === rankB) {
          return collator.compare(a.name, b.name);
        }
        return rankA - rankB;
      });

      buildTableHead(subjects);
      tableBody.innerHTML = '';

      sorted.forEach(summary => {
        const tr = document.createElement('tr');
        const rank = overallRanks[summary.name];
        const numberCell = summary.number ? summary.number : '-';
        const sumCell = Number.isFinite(summary.totalSum) ? summary.totalSum.toFixed(1) : '-';
        const avgCell = Number.isFinite(summary.average) ? summary.average.toFixed(1) : '-';

        const subjectCells = subjects.map((_, idx) => createSubjectCell(summary, idx, subjectGrades));
        tr.innerHTML = `
          <td>${numberCell}</td>
          <td>${summary.name}</td>
          <td>${sumCell}</td>
          <td>${avgCell}</td>
          ${subjectCells.join('')}
          <td class="rank-cell">${typeof rank === 'number' ? `${rank}위` : '-'}</td>
        `;
        tableBody.appendChild(tr);
      });

      noticeEl.classList.remove('warning');
      noticeEl.textContent = `총 ${sorted.length}명의 학생 데이터를 분석했습니다.`;
      tableWrapper.style.display = '';
    }

    function buildStudentSummary(name, info, subjects) {
      const subjectAverages = subjects.map((_, idx) => computeSubjectAverage(info, idx));
      const validScores = subjectAverages.filter(score => Number.isFinite(score));
      const totalSum = validScores.length ? validScores.reduce((sum, value) => sum + value, 0) : null;
      const average = validScores.length ? totalSum / validScores.length : null;
      return {
        name,
        number: typeof info.number === 'number' ? String(info.number) : (info.number || ''),
        subjectAverages,
        totalSum,
        average
      };
    }

    function computeSubjectAverage(info, index) {
      const values = [];
      addIfValid(values, info.semester1, index);
      addIfValid(values, info.semester2, index);
      addIfValid(values, info.semester3, index);
      if (!values.length) return null;
      const sum = values.reduce((acc, cur) => acc + cur, 0);
      return sum / values.length;
    }

    function addIfValid(target, term, index) {
      if (!Array.isArray(term)) return;
      const value = term[index];
      if (typeof value === 'number' && Number.isFinite(value)) {
        target.push(value);
      }
    }

    function computeOverallRanks(summaries) {
      const ranked = {};
      const sorted = summaries.slice().sort((a, b) => {
        const avgA = Number.isFinite(a.average) ? a.average : -Infinity;
        const avgB = Number.isFinite(b.average) ? b.average : -Infinity;
        return avgB - avgA;
      });

      let currentRank = 0;
      let previousScore = null;
      sorted.forEach((summary, index) => {
        if (!Number.isFinite(summary.average)) {
          ranked[summary.name] = '-';
          return;
        }
        const normalized = Number(summary.average.toFixed(4));
        if (previousScore !== null && Math.abs(normalized - previousScore) < 1e-6) {
          ranked[summary.name] = currentRank;
        } else {
          currentRank = index + 1;
          ranked[summary.name] = currentRank;
          previousScore = normalized;
        }
      });

      summaries.forEach(summary => {
        if (!Number.isFinite(summary.average)) {
          ranked[summary.name] = '-';
        }
      });

      return ranked;
    }

    function computeSubjectGrades(subjects, summaries) {
      const gradeMap = {};
      summaries.forEach(summary => {
        gradeMap[summary.name] = Array(subjects.length).fill('-');
      });

      subjects.forEach((_, idx) => {
        const subjectScores = summaries
          .map(summary => ({ name: summary.name, score: summary.subjectAverages[idx] }))
          .filter(entry => Number.isFinite(entry.score))
          .sort((a, b) => b.score - a.score);

        if (!subjectScores.length) {
          return;
        }

        const boundaries = buildGradeBoundaries(subjectScores.length);
        subjectScores.forEach((entry, position) => {
          let grade = gradeForRank(position + 1, boundaries);
          if (position > 0) {
            const previous = subjectScores[position - 1];
            if (Math.abs(entry.score - previous.score) < 1e-6) {
              grade = previous.assignedGrade;
            }
          }
          entry.assignedGrade = grade;
          gradeMap[entry.name][idx] = grade;
        });
      });

      return gradeMap;
    }

    function buildGradeBoundaries(total) {
      const slots = [];
      let running = 0;
      let previousCumulative = 0;

      GRADE_CONFIG.forEach((config, index) => {
        running += total * (config.percent / 100);
        let cumulative = index === GRADE_CONFIG.length - 1 ? total : Math.round(running);
        cumulative = Math.min(Math.max(cumulative, previousCumulative), total);
        const count = cumulative - previousCumulative;
        slots.push({ grade: config.label, count });
        previousCumulative = cumulative;
      });

      const assignedTotal = slots.reduce((sum, slot) => sum + slot.count, 0);
      if (assignedTotal < total && slots.length) {
        slots[slots.length - 1].count += total - assignedTotal;
      }

      const boundaries = [];
      let cumulative = 0;
      slots.forEach(slot => {
        if (slot.count <= 0) return;
        cumulative += slot.count;
        boundaries.push({ grade: slot.grade, maxRank: cumulative });
      });

      if (!boundaries.length) {
        boundaries.push({ grade: GRADE_CONFIG[GRADE_CONFIG.length - 1].label, maxRank: total });
      }

      return boundaries;
    }

    function gradeForRank(rank, boundaries) {
      for (const boundary of boundaries) {
        if (rank <= boundary.maxRank) {
          return boundary.grade;
        }
      }
      return boundaries.length ? boundaries[boundaries.length - 1].grade : '-';
    }

    function createSubjectCell(summary, index, gradeMap) {
      const average = summary.subjectAverages[index];
      const grade = gradeMap[summary.name]?.[index] ?? '-';
      const parts = [];
      if (Number.isFinite(average)) {
        parts.push(`<span class="score">${average.toFixed(1)}점</span>`);
      }
      if (grade !== '-') {
        parts.push(`<span class="grade-tag ${gradeBadgeClass(grade)}">${grade}</span>`);
      }
      if (!parts.length) {
        return '<td class="subject-grade">-</td>';
      }
      return `<td class="subject-grade">${parts.join('')}</td>`;
    }

    function gradeBadgeClass(grade) {
      const match = /^([1-5])/.exec(grade);
      if (!match) return '';
      return `is-${match[1]}`;
    }

    function buildTableHead(subjects) {
      const headerRow = document.createElement('tr');
      headerRow.innerHTML = `
        <th>학번</th>
        <th>이름</th>
        <th>합계</th>
        <th>평균</th>
        ${subjects.map(subject => `<th>${subject} 등급</th>`).join('')}
        <th>전체 등수</th>
      `;
      tableHead.innerHTML = '';
      tableHead.appendChild(headerRow);
    }

    function rankValue(rank) {
      return typeof rank === 'number' ? rank : Number.POSITIVE_INFINITY;
    }
  </script>
</body>
</html>
